import multiprocessing as mp
import pandas as pd
import numpy as np
import time
import queue
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class StrategyStatus(Enum):
    """Status of active strategies"""
    ACTIVE = "ACTIVE"
    MONITORING = "MONITORING"  # Position established, monitoring for exit
    SCALING = "SCALING"  # Adjusting position size
    EXITING = "EXITING"  # Exit signal triggered
    COMPLETED = "COMPLETED"  # Strategy cycle complete
    STOPPED = "STOPPED"  # Stopped due to risk limits

@dataclass
class ActiveStrategy:
    """Tracks an active strategy for a symbol"""
    symbol: str
    strategy_type: str  # 'momentum', 'mean_reversion', 'bollinger', etc.
    entry_time: datetime
    entry_price: float
    current_price: float = 0.0
    position_size: float = 0.0  # Current position size (0.0 to 0.15)
    target_size: float = 0.0  # Target position size
    status: StrategyStatus = StrategyStatus.ACTIVE

    # Performance tracking
    unrealized_pnl: float = 0.0
    unrealized_pnl_pct: float = 0.0
    high_water_mark: float = 0.0
    max_drawdown: float = 0.0

    # Risk metrics
    current_volatility: float = 0.0
    risk_score: float = 0.0

    # Strategy-specific parameters
    parameters: Dict[str, Any] = field(default_factory=dict)
    exit_conditions: Dict[str, Any] = field(default_factory=dict)

    # Tracking history
    price_history: List[float] = field(default_factory=list)
    size_history: List[float] = field(default_factory=list)
    update_times: List[datetime] = field(default_factory=list)

    def update_metrics(self, current_price: float, current_volatility: float = None):
        """Update strategy metrics with current price"""
        self.current_price = current_price
        self.price_history.append(current_price)
        self.update_times.append(datetime.now())

        # Update P&L
        if self.position_size > 0:
            self.unrealized_pnl = (current_price - self.entry_price) * self.position_size
            self.unrealized_pnl_pct = ((current_price / self.entry_price) - 1) * 100

            # Update high water mark and drawdown
            if current_price > self.high_water_mark:
                self.high_water_mark = current_price

            self.max_drawdown = min(self.max_drawdown,
                                   ((current_price - self.high_water_mark) / self.high_water_mark) * 100)

        if current_volatility:
            self.current_volatility = current_volatility

    def time_in_position(self) -> timedelta:
        """Calculate time since entry"""
        return datetime.now() - self.entry_time

@dataclass
class StrategyAlert:
    """Alert generated by strategy monitoring"""
    symbol: str
    strategy_type: str
    alert_type: str  # 'EXIT', 'SCALE_UP', 'SCALE_DOWN', 'RISK_WARNING'
    severity: str  # 'INFO', 'WARNING', 'CRITICAL'
    message: str
    action_required: str
    metrics: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.now)

def strategy_monitor_worker(task_queue: mp.Queue, result_queue: mp.Queue):
    """Worker that monitors active strategies"""

    # Import strategy modules
    try:
        from trading_engine.portfolio_manager.strategies import (
            MomentumStrategy, MeanReversionStrategy, BollingerStrategy,
            VolatilityStrategy, PCAStrategy, JumpDiffusionStrategy
        )

        # Strategy mapping
        strategy_map = {
            'momentum': MomentumStrategy(),
            'mean_reversion': MeanReversionStrategy(),
            'bollinger': BollingerStrategy(),
            'volatility': VolatilityStrategy(),
            'pca_momentum': PCAStrategy(strategy_type='factor_momentum'),
            'jump_momentum': JumpDiffusionStrategy(strategy_type='jump_momentum')
        }
        has_strategies = True
    except ImportError:
        strategy_map = {}
        has_strategies = False
        logger.warning("Using mock strategy monitoring")

    while True:
        try:
            task = task_queue.get(timeout=2)
            if task is None:
                break

            symbol = task['symbol']
            active_strategy = task['active_strategy']
            market_data = pd.DataFrame(task['market_data'])
            task_type = task['task_type']

            try:
                if task_type == 'monitor_exit':
                    # Check exit conditions
                    result = _check_exit_conditions(
                        active_strategy, market_data, strategy_map, has_strategies
                    )

                elif task_type == 'monitor_scaling':
                    # Check if position should be scaled
                    result = _check_scaling_conditions(
                        active_strategy, market_data, task.get('portfolio_state', {})
                    )

                elif task_type == 'monitor_risk':
                    # Monitor risk metrics
                    result = _check_risk_conditions(
                        active_strategy, market_data, task.get('risk_limits', {})
                    )

                elif task_type == 'update_metrics':
                    # Update strategy metrics only
                    result = _update_strategy_metrics(active_strategy, market_data)

                else:
                    result = {'success': False, 'error': f'Unknown task type: {task_type}'}

                result['symbol'] = symbol
                result['strategy_type'] = active_strategy.strategy_type
                result['task_type'] = task_type

            except Exception as e:
                logger.error(f"Error monitoring {symbol}: {e}")
                result = {
                    'symbol': symbol,
                    'task_type': task_type,
                    'success': False,
                    'error': str(e)
                }

            result_queue.put(result)

        except queue.Empty:
            continue
        except Exception as e:
            logger.error(f"Worker error: {e}")
            continue

def _check_exit_conditions(active_strategy: ActiveStrategy,
                          market_data: pd.DataFrame,
                          strategy_map: Dict,
                          has_strategies: bool) -> Dict[str, Any]:
    """Check if strategy should exit"""

    current_price = market_data['Close'].iloc[-1]
    active_strategy.update_metrics(current_price)

    alerts = []
    should_exit = False
    exit_reason = ""

    # 1. Check strategy-specific exit conditions
    if has_strategies and active_strategy.strategy_type in strategy_map:
        strategy = strategy_map[active_strategy.strategy_type]
        signal = strategy.generate_signal(market_data)

        if signal.action == 'SELL' and active_strategy.position_size > 0:
            should_exit = True
            exit_reason = f"Strategy signal: {signal.reasoning}"
            alerts.append(StrategyAlert(
                symbol=active_strategy.symbol,
                strategy_type=active_strategy.strategy_type,
                alert_type='EXIT',
                severity='WARNING',
                message=exit_reason,
                action_required='SELL',
                metrics={'confidence': signal.confidence}
            ))

    # 2. Check time-based exits
    time_in_position = active_strategy.time_in_position()
    max_holding_period = active_strategy.exit_conditions.get('max_holding_days', 30)

    if time_in_position.days >= max_holding_period:
        should_exit = True
        exit_reason = f"Max holding period reached ({time_in_position.days} days)"
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='EXIT',
            severity='INFO',
            message=exit_reason,
            action_required='SELL',
            metrics={'days_held': time_in_position.days}
        ))

    # 3. Check profit targets
    profit_target = active_strategy.exit_conditions.get('profit_target_pct', 15.0)
    if active_strategy.unrealized_pnl_pct >= profit_target:
        should_exit = True
        exit_reason = f"Profit target reached ({active_strategy.unrealized_pnl_pct:.1f}%)"
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='EXIT',
            severity='INFO',
            message=exit_reason,
            action_required='SELL',
            metrics={'profit_pct': active_strategy.unrealized_pnl_pct}
        ))

    # 4. Check stop loss
    stop_loss = active_strategy.exit_conditions.get('stop_loss_pct', -8.0)
    if active_strategy.unrealized_pnl_pct <= stop_loss:
        should_exit = True
        exit_reason = f"Stop loss triggered ({active_strategy.unrealized_pnl_pct:.1f}%)"
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='EXIT',
            severity='CRITICAL',
            message=exit_reason,
            action_required='SELL',
            metrics={'loss_pct': active_strategy.unrealized_pnl_pct}
        ))

    # 5. Check trailing stop
    trailing_stop = active_strategy.exit_conditions.get('trailing_stop_pct', -5.0)
    if active_strategy.max_drawdown <= trailing_stop:
        should_exit = True
        exit_reason = f"Trailing stop triggered (drawdown: {active_strategy.max_drawdown:.1f}%)"
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='EXIT',
            severity='WARNING',
            message=exit_reason,
            action_required='SELL',
            metrics={'drawdown': active_strategy.max_drawdown}
        ))

    return {
        'success': True,
        'should_exit': should_exit,
        'exit_reason': exit_reason,
        'alerts': alerts,
        'current_metrics': {
            'price': current_price,
            'pnl': active_strategy.unrealized_pnl,
            'pnl_pct': active_strategy.unrealized_pnl_pct,
            'time_in_position': time_in_position.total_seconds() / 3600  # hours
        }
    }

def _check_scaling_conditions(active_strategy: ActiveStrategy,
                            market_data: pd.DataFrame,
                            portfolio_state: Dict) -> Dict[str, Any]:
    """Check if position should be scaled up or down"""

    current_price = market_data['Close'].iloc[-1]
    active_strategy.update_metrics(current_price)

    alerts = []
    scaling_action = "HOLD"
    scaling_reason = ""
    new_size = active_strategy.position_size

    # Calculate current volatility
    returns = market_data['Close'].pct_change().dropna()
    current_vol = returns.std() * np.sqrt(252)

    # 1. Scale down if volatility increased significantly
    vol_threshold = active_strategy.parameters.get('vol_scale_threshold', 0.35)
    if current_vol > vol_threshold and active_strategy.position_size > 0.05:
        scaling_factor = vol_threshold / current_vol
        new_size = active_strategy.position_size * scaling_factor
        scaling_action = "SCALE_DOWN"
        scaling_reason = f"High volatility ({current_vol:.1%})"

        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='SCALE_DOWN',
            severity='WARNING',
            message=scaling_reason,
            action_required='REDUCE_POSITION',
            metrics={'current_vol': current_vol, 'new_size': new_size}
        ))

    # 2. Scale up if performing well with low volatility
    elif (active_strategy.unrealized_pnl_pct > 5.0 and
          current_vol < 0.20 and
          active_strategy.position_size < active_strategy.target_size):
        new_size = min(active_strategy.target_size, active_strategy.position_size * 1.2)
        scaling_action = "SCALE_UP"
        scaling_reason = f"Strong performance with low volatility"

        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='SCALE_UP',
            severity='INFO',
            message=scaling_reason,
            action_required='INCREASE_POSITION',
            metrics={'current_vol': current_vol, 'new_size': new_size, 'pnl_pct': active_strategy.unrealized_pnl_pct}
        ))

    # 3. Scale down if approaching stop loss
    stop_loss = active_strategy.exit_conditions.get('stop_loss_pct', -8.0)
    if active_strategy.unrealized_pnl_pct < stop_loss / 2:  # Halfway to stop loss
        new_size = active_strategy.position_size * 0.5
        scaling_action = "SCALE_DOWN"
        scaling_reason = f"Approaching stop loss ({active_strategy.unrealized_pnl_pct:.1f}%)"

        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='SCALE_DOWN',
            severity='WARNING',
            message=scaling_reason,
            action_required='REDUCE_POSITION',
            metrics={'pnl_pct': active_strategy.unrealized_pnl_pct, 'new_size': new_size}
        ))

    return {
        'success': True,
        'scaling_action': scaling_action,
        'scaling_reason': scaling_reason,
        'current_size': active_strategy.position_size,
        'new_size': new_size,
        'size_change': new_size - active_strategy.position_size,
        'alerts': alerts
    }

def _check_risk_conditions(active_strategy: ActiveStrategy,
                          market_data: pd.DataFrame,
                          risk_limits: Dict) -> Dict[str, Any]:
    """Monitor risk conditions and generate alerts"""

    current_price = market_data['Close'].iloc[-1]
    returns = market_data['Close'].pct_change().dropna()
    current_vol = returns.std() * np.sqrt(252)

    active_strategy.update_metrics(current_price, current_vol)

    alerts = []
    risk_score = 0

    # 1. Volatility risk
    vol_limit = risk_limits.get('max_volatility', 0.50)
    if current_vol > vol_limit:
        risk_score += 30
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='RISK_WARNING',
            severity='CRITICAL',
            message=f"Volatility exceeds limit ({current_vol:.1%} > {vol_limit:.1%})",
            action_required='REVIEW_POSITION',
            metrics={'volatility': current_vol}
        ))

    # 2. Drawdown risk
    max_drawdown_limit = risk_limits.get('max_drawdown', -10.0)
    if active_strategy.max_drawdown < max_drawdown_limit:
        risk_score += 25
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='RISK_WARNING',
            severity='WARNING',
            message=f"Drawdown exceeds limit ({active_strategy.max_drawdown:.1f}%)",
            action_required='CONSIDER_EXIT',
            metrics={'drawdown': active_strategy.max_drawdown}
        ))

    # 3. Correlation risk (simplified)
    if len(market_data) >= 20:
        market_correlation = returns.rolling(20).corr(returns.shift(1)).iloc[-1]
        if abs(market_correlation) > 0.8:
            risk_score += 15
            alerts.append(StrategyAlert(
                symbol=active_strategy.symbol,
                strategy_type=active_strategy.strategy_type,
                alert_type='RISK_WARNING',
                severity='INFO',
                message=f"High autocorrelation detected ({market_correlation:.2f})",
                action_required='MONITOR',
                metrics={'correlation': market_correlation}
            ))

    # 4. Position concentration risk
    position_limit = risk_limits.get('max_position_size', 0.15)
    if active_strategy.position_size > position_limit * 0.9:
        risk_score += 10
        alerts.append(StrategyAlert(
            symbol=active_strategy.symbol,
            strategy_type=active_strategy.strategy_type,
            alert_type='RISK_WARNING',
            severity='INFO',
            message=f"Position near size limit ({active_strategy.position_size:.1%})",
            action_required='NO_INCREASE',
            metrics={'position_size': active_strategy.position_size}
        ))

    active_strategy.risk_score = risk_score

    return {
        'success': True,
        'risk_score': risk_score,
        'risk_level': 'HIGH' if risk_score > 50 else 'MEDIUM' if risk_score > 25 else 'LOW',
        'alerts': alerts,
        'risk_metrics': {
            'volatility': current_vol,
            'max_drawdown': active_strategy.max_drawdown,
            'position_size': active_strategy.position_size,
            'pnl_pct': active_strategy.unrealized_pnl_pct
        }
    }

def _update_strategy_metrics(active_strategy: ActiveStrategy,
                           market_data: pd.DataFrame) -> Dict[str, Any]:
    """Update strategy metrics without generating alerts"""

    current_price = market_data['Close'].iloc[-1]
    returns = market_data['Close'].pct_change().dropna()
    current_vol = returns.std() * np.sqrt(252)

    active_strategy.update_metrics(current_price, current_vol)

    # Calculate additional metrics
    sharpe_ratio = (returns.mean() / returns.std() * np.sqrt(252)) if returns.std() > 0 else 0

    return {
        'success': True,
        'metrics': {
            'current_price': current_price,
            'entry_price': active_strategy.entry_price,
            'pnl': active_strategy.unrealized_pnl,
            'pnl_pct': active_strategy.unrealized_pnl_pct,
            'volatility': current_vol,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': active_strategy.max_drawdown,
            'time_in_position': active_strategy.time_in_position().total_seconds() / 3600
        }
    }


class StrategyTrackingMultiprocessor:
    """
    Multiprocessor for tracking active strategies in real-time
    """

    def __init__(self, check_frequency_seconds: int = 60):
        """
        Args:
            check_frequency_seconds: How often to check each strategy
        """
        self.check_frequency = check_frequency_seconds
        self.memory_gb = self._get_memory_gb()

        # Initialize queues
        self.task_queue = mp.Queue()
        self.result_queue = mp.Queue()
        self.workers = []

        # Configure based on instance size
        if self.memory_gb < 1:  # t3.nano/micro
            self.num_workers = 1
            self.max_strategies = 20
        elif self.memory_gb < 4:  # t3.small
            self.num_workers = 2
            self.max_strategies = 50
        elif self.memory_gb < 8:  # t3.medium
            self.num_workers = 3
            self.max_strategies = 100
        else:  # t3.large+
            self.num_workers = 4
            self.max_strategies = 200

        # Active strategies storage
        self.active_strategies: Dict[str, ActiveStrategy] = {}

        logger.info(f"Strategy tracker configured: {self.num_workers} workers, max {self.max_strategies} strategies")

    def _get_memory_gb(self) -> float:
        """Get total virtual memory"""
        try:
            import psutil
            return psutil.virtual_memory().total / (1024**3)
        except:
            return 4.0

    def start_workers(self):
        """Start the worker processes"""
        for i in range(self.num_workers):
            worker = mp.Process(
                target=strategy_monitor_worker,
                args=(self.task_queue, self.result_queue),
                name=f'StrategyMonitor-{i}'
            )
            worker.start()
            self.workers.append(worker)

        logger.info(f'Started {len(self.workers)} strategy monitoring workers')

    def add_strategy(self, strategy: ActiveStrategy):
        """Add a new strategy to track"""
        if len(self.active_strategies) >= self.max_strategies:
            logger.warning(f"Max strategies reached ({self.max_strategies})")
            return False

        self.active_strategies[strategy.symbol] = strategy
        logger.info(f"Added strategy: {strategy.symbol} ({strategy.strategy_type})")
        return True

    def remove_strategy(self, symbol: str):
        """Remove a strategy from tracking"""
        if symbol in self.active_strategies:
            strategy = self.active_strategies.pop(symbol)
            strategy.status = StrategyStatus.COMPLETED
            logger.info(f"Removed strategy: {symbol}")
            return strategy
        return None

    def monitor_all_strategies(self, market_data_dict: Dict[str, pd.DataFrame],
                             portfolio_state: Optional[Dict] = None,
                             risk_limits: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Monitor all active strategies

        Returns:
            Dict containing alerts, metrics, and recommended actions
        """
        if not self.active_strategies:
            return {'alerts': [], 'metrics': {}, 'actions': []}

        self.start_workers()
        start_time = time.time()

        # Submit monitoring tasks
        task_count = 0
        for symbol, strategy in self.active_strategies.items():
            if symbol not in market_data_dict:
                continue

            # Submit different monitoring tasks
            for task_type in ['monitor_exit', 'monitor_scaling', 'monitor_risk', 'update_metrics']:
                task = {
                    'symbol': symbol,
                    'active_strategy': strategy,
                    'market_data': market_data_dict[symbol].tail(100).to_dict('records'),
                    'task_type': task_type,
                    'portfolio_state': portfolio_state,
                    'risk_limits': risk_limits or {}
                }
                self.task_queue.put(task)
                task_count += 1

        # Collect results
        results = self._collect_monitoring_results(task_count)

        # Process results into actionable format
        processed_results = self._process_monitoring_results(results)

        # Update strategy statuses
        self._update_strategy_statuses(processed_results)

        total_time = time.time() - start_time
        logger.info(f"Monitored {len(self.active_strategies)} strategies in {total_time:.1f}s")

        self.shutdown()

        return {
            'alerts': processed_results['alerts'],
            'actions': processed_results['actions'],
            'metrics': processed_results['metrics'],
            'summary': processed_results['summary'],
            'processing_time': total_time
        }

    def _collect_monitoring_results(self, expected_count: int) -> List[Dict]:
        """Collect results from workers"""
        results = []
        collected = 0
        timeout = 30
        start_time = time.time()

        while collected < expected_count and time.time() - start_time < timeout:
            try:
                result = self.result_queue.get(timeout=1)
                results.append(result)
                collected += 1
            except queue.Empty:
                continue

        return results

    def _process_monitoring_results(self, results: List[Dict]) -> Dict[str, Any]:
        """Process raw monitoring results into actionable format"""
        all_alerts = []
        recommended_actions = []
        strategy_metrics = {}

        # Group results by symbol
        symbol_results = {}
        for result in results:
            if result.get('success'):
                symbol = result['symbol']
                if symbol not in symbol_results:
                    symbol_results[symbol] = {}
                symbol_results[symbol][result['task_type']] = result

        # Process each symbol's results
        for symbol, task_results in symbol_results.items():
            # Collect alerts
            for task_type, result in task_results.items():
                if 'alerts' in result:
                    all_alerts.extend(result['alerts'])

            # Generate recommended actions
            exit_result = task_results.get('monitor_exit', {})
            scaling_result = task_results.get('monitor_scaling', {})
            risk_result = task_results.get('monitor_risk', {})
            metrics_result = task_results.get('update_metrics', {})

            if exit_result.get('should_exit'):
                recommended_actions.append({
                    'symbol': symbol,
                    'action': 'EXIT',
                    'reason': exit_result['exit_reason'],
                    'urgency': 'HIGH',
                    'metrics': exit_result.get('current_metrics', {})
                })
            elif scaling_result.get('scaling_action') != 'HOLD':
                recommended_actions.append({
                    'symbol': symbol,
                    'action': scaling_result['scaling_action'],
                    'new_size': scaling_result['new_size'],
                    'size_change': scaling_result['size_change'],
                    'reason': scaling_result['scaling_reason'],
                    'urgency': 'MEDIUM'
                })

            # Collect metrics
            if metrics_result.get('metrics'):
                strategy_metrics[symbol] = metrics_result['metrics']

        # Generate summary
        summary = {
            'total_strategies': len(self.active_strategies),
            'strategies_monitored': len(symbol_results),
            'total_alerts': len(all_alerts),
            'critical_alerts': len([a for a in all_alerts if a.severity == 'CRITICAL']),
            'recommended_actions': len(recommended_actions),
            'exit_signals': len([a for a in recommended_actions if a['action'] == 'EXIT']),
            'scaling_signals': len([a for a in recommended_actions if 'SCALE' in a['action']])
        }

        return {
            'alerts': sorted(all_alerts, key=lambda x: x.timestamp, reverse=True),
            'actions': sorted(recommended_actions,
                            key=lambda x: {'HIGH': 0, 'MEDIUM': 1, 'LOW': 2}[x['urgency']]),
            'metrics': strategy_metrics,
            'summary': summary
        }

    def _update_strategy_statuses(self, processed_results: Dict):
        """Update strategy statuses based on monitoring results"""
        for action in processed_results['actions']:
            symbol = action['symbol']
            if symbol in self.active_strategies:
                strategy = self.active_strategies[symbol]

                if action['action'] == 'EXIT':
                    strategy.status = StrategyStatus.EXITING
                elif action['action'] in ['SCALE_UP', 'SCALE_DOWN']:
                    strategy.status = StrategyStatus.SCALING

    def get_strategy_summary(self) -> Dict[str, Any]:
        """Get summary of all active strategies"""
        if not self.active_strategies:
            return {'active_count': 0, 'strategies': []}

        strategy_list = []
        total_pnl = 0
        total_allocation = 0

        for symbol, strategy in self.active_strategies.items():
            strategy_info = {
                'symbol': symbol,
                'strategy_type': strategy.strategy_type,
                'status': strategy.status.value,
                'position_size': strategy.position_size,
                'pnl': strategy.unrealized_pnl,
                'pnl_pct': strategy.unrealized_pnl_pct,
                'time_active': str(strategy.time_in_position()),
                'risk_score': strategy.risk_score
            }
            strategy_list.append(strategy_info)
            total_pnl += strategy.unrealized_pnl
            total_allocation += strategy.position_size

        return {
            'active_count': len(self.active_strategies),
            'total_allocation': total_allocation,
            'total_pnl': total_pnl,
            'strategies': sorted(strategy_list, key=lambda x: x['pnl'], reverse=True),
            'status_breakdown': {
                status.value: len([s for s in self.active_strategies.values()
                                 if s.status == status])
                for status in StrategyStatus
            }
        }

    def shutdown(self):
        """
        Shutdown all worker processes gracefully and clean up queues.
        """
        # 1. Send a sentinel (None) to each worker so they break out of their loop
        for _ in self.workers:
            self.task_queue.put(None)
        # 2. Join each worker, giving them a little time to exit cleanly
        for worker in self.workers:
            worker.join(timeout=5)
            if worker.is_alive():
                logger.warning(f"{worker.name} did not exit in time; terminating")
                worker.terminate()
        # 3. Clean up queues
        try:
            self.task_queue.close()
            self.result_queue.close()
        except Exception as e:
            logger.warning(f"Error closing queues: {e}")
        # 4. Reset state
        self.workers = []
        logger.info("All workers shut down and queues closed")

if __name__ == '__main__':
    # Create a few mock strategies and some fake market data
    tracker = StrategyTrackingMultiprocessor(check_frequency_seconds=10)

    # Add mock strategies
    now = datetime.now()
    s1 = ActiveStrategy(
        symbol='AAPL',
        strategy_type='momentum',
        entry_time=now - timedelta(hours=2),
        entry_price=150.0,
        position_size=0.1,
        target_size=0.15,
        exit_conditions={'max_holding_days': 1, 'profit_target_pct': 2.0, 'stop_loss_pct': -1.0},
        parameters={'vol_scale_threshold': 0.3}
    )
    s2 = ActiveStrategy(
        symbol='MSFT',
        strategy_type='mean_reversion',
        entry_time=now - timedelta(hours=5),
        entry_price=300.0,
        position_size=0.05,
        target_size=0.1,
        exit_conditions={'max_holding_days': 2, 'profit_target_pct': 3.0, 'stop_loss_pct': -1.5},
        parameters={'vol_scale_threshold': 0.25}
    )

    tracker.add_strategy(s1)
    tracker.add_strategy(s2)

    # Generate fake market data for each symbol
    dates = pd.date_range(end=now, periods=100, freq='T')
    prices_aapl = 150 + np.cumsum(np.random.normal(0, 0.1, size=len(dates)))
    prices_msft = 300 + np.cumsum(np.random.normal(0, 0.2, size=len(dates)))

    market_data = {
        'AAPL': pd.DataFrame({'Close': prices_aapl}, index=dates),
        'MSFT': pd.DataFrame({'Close': prices_msft}, index=dates)
    }

    # Run one monitoring cycle
    results = tracker.monitor_all_strategies(
        market_data_dict=market_data,
        portfolio_state={'total_value': 1_000_000},
        risk_limits={'max_volatility': 0.5, 'max_drawdown': -5.0, 'max_position_size': 0.2}
    )

    # Inspect the outputs
    print("Summary:", results['summary'])
    print("Alerts:")
    for alert in results['alerts']:
        print(f" - [{alert.severity}] {alert.symbol}: {alert.message}")
    print("Recommended Actions:", results['actions'])

