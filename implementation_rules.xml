<?xml version="1.0" encoding="UTF-8"?>
<trading_system_implementation_rules>
    <!-- CORE ARCHITECTURAL CONSTRAINTS -->
    <infrastructure_constraints>
        <ec2_optimization>
            <cpu_cores>2</cpu_cores>
            <max_processes>5</max_processes>
            <memory_efficient>true</memory_efficient>
            <background_processes>minimize</background_processes>
        </ec2_optimization>

        <process_architecture>
            <main_process>decision_engine + orchestrator</main_process>
            <separate_processes>position_health_monitor, strategy_analyzer, sentiment_analyzer, regime_detector</separate_processes>
            <inheritance_pattern>BaseProcess for all processes</inheritance_pattern>
        </process_architecture>
    </infrastructure_constraints>

    <!-- STRATEGY MANAGEMENT RULES -->
    <strategy_management>
        <post_execution_behavior>
            <assignment_timing>IMMEDIATE after successful trade execution</assignment_timing>
            <strategy_continuity>Use entry strategy as initial monitoring strategy</strategy_continuity>
            <transition_trigger>ONLY on multiple confirming signals</transition_trigger>
            <forced_transitions>regime_change + poor_performance + sentiment_shift</forced_transitions>
        </post_execution_behavior>

        <implementation_locations>
            <primary_logic>decision_engine.py</primary_logic>
            <conflict_resolution>conflict_manager.py</conflict_resolution>
            <strategy_utilities>strategy_selector.py (pure utility, no business logic)</strategy_utilities>
        </implementation_locations>

        <state_management>
            <active_strategy_enum>MonitoringStrategyStatus</active_strategy_enum>
            <strategy_persistence>shared_memory + database</strategy_persistence>
            <transition_logging>full audit trail required</transition_logging>
        </state_management>
    </strategy_management>

    <!-- QUEUE AND MESSAGING PATTERNS -->
    <messaging_architecture>
        <message_types>
            <add>STRATEGY_ASSIGNMENT, STRATEGY_REASSESSMENT_REQUEST, STRATEGY_TRANSITION, MONITORING_STRATEGY_UPDATE, API_RATE_LIMIT_WARNING</add>
            <priority_mapping>CRITICAL for exits, HIGH for transitions, NORMAL for assignments</priority_mapping>
        </message_types>

        <flow_patterns>
            <post_execution>Decision Engine → Queue → Position Health Monitor (strategy assignment)</post_execution>
            <reassessment>Health Monitor → Queue → Decision Engine (reassessment request)</reassessment>
            <transitions>Decision Engine → Queue → ALL_INTERESTED (strategy change broadcast)</transitions>
        </flow_patterns>

        <api_data_flow>
            <frequency>Every 5-10 seconds for swing trading</frequency>
            <symbols_limit>Max 3-5 symbols to stay within Alpaca rate limits</symbols_limit>
            <shared_memory_pattern>Latest data overwrites, 30-second history buffer</shared_memory_pattern>
        </api_data_flow>
    </messaging_architecture>

    <!-- CODE IMPLEMENTATION STANDARDS -->
    <coding_standards>
        <imports_and_dependencies>
            <pattern>Try real imports first, fallback stubs with clear warnings</pattern>
            <missing_components>Graceful degradation, log warnings, continue operation</missing_components>
            <circular_imports>Avoid by using interfaces and late imports</circular_imports>
        </imports_and_dependencies>

        <error_handling>
            <api_failures>Exponential backoff, fallback to cached data</api_failures>
            <strategy_failures>Log, revert to conservative default, alert</strategy_failures>
            <queue_failures>Critical alerts, fallback to direct calls</queue_failures>
            <shared_memory_corruption>Rebuild state from database, continue</shared_memory_corruption>
        </error_handling>

        <logging_requirements>
            <decision_audit>Every strategy assignment/transition with full context</decision_audit>
            <performance_tracking>Execution time, memory usage, API call count</performance_tracking>
            <debug_info>Queue sizes, shared memory state, process health</debug_info>
        </logging_requirements>
    </coding_standards>

    <!-- SPECIFIC IMPLEMENTATION REQUIREMENTS -->
    <implementation_specifics>
        <decision_engine_enhancements>
            <add_methods>
                <method>_assign_monitoring_strategy(symbol, entry_strategy, execution_result)</method>
                <method>_handle_strategy_reassessment_request(message)</method>
                <method>_evaluate_strategy_transition(symbol, signals)</method>
                <method>_broadcast_strategy_change(symbol, old_strategy, new_strategy)</method>
            </add_methods>

            <state_tracking>
                <add_attributes>active_monitoring_strategies: Dict[str, MonitoringStrategyStatus]</add_attributes>
                <add_attributes>strategy_transition_signals: Dict[str, List[TransitionSignal]]</add_attributes>
                <add_attributes>api_rate_limiter: RateLimiter</add_attributes>
            </state_tracking>
        </decision_engine_enhancements>

        <conflict_manager_enhancements>
            <add_methods>
                <method>evaluate_strategy_transition_conflict(current_strategy, proposed_strategy, signals)</method>
                <method>require_multiple_signals_confirmation(symbol, transition_type)</method>
                <method>resolve_strategy_priority_conflict(competing_strategies)</method>
            </add_methods>

            <multi_signal_logic>
                <requirement>Minimum 2-3 confirming signals for strategy transitions</requirement>
                <time_window>Signals must occur within 15-minute window</time_window>
                <confidence_threshold>Combined confidence > 0.75 for transitions</confidence_threshold>
            </multi_signal_logic>
        </conflict_manager_enhancements>

        <shared_memory_additions>
            <market_data_structure>
                <real_time_prices>Latest price per symbol with timestamp</real_time_prices>
                <price_history>30-second rolling buffer per symbol</price_history>
                <api_call_tracker>Rate limit tracking and optimization</api_call_tracker>
            </market_data_structure>

            <strategy_state>
                <active_strategies>Current monitoring strategy per position</active_strategies>
                <transition_candidates>Pending strategy changes awaiting confirmation</transition_candidates>
                <performance_metrics>Real-time strategy performance tracking</performance_metrics>
            </strategy_state>
        </shared_memory_additions>
    </implementation_specifics>

    <!-- TESTING AND VALIDATION -->
    <testing_requirements>
        <unit_tests>
            <focus>Strategy assignment logic, transition evaluation, message handling</focus>
            <mock_dependencies>Alpaca API, shared memory, queue system</mock_dependencies>
        </unit_tests>

        <integration_tests>
            <scenarios>Full execution → assignment → monitoring → reassessment → transition flow</scenarios>
            <performance>API rate limit compliance, memory usage under load</performance>
        </integration_tests>

        <validation_scripts>
            <extend>validate_requirements.py to include new message types and strategies</extend>
            <add>strategy_management_validator.py for post-execution flows</add>
        </validation_scripts>
    </testing_requirements>

    <!-- PERFORMANCE OPTIMIZATION -->
    <optimization_rules>
        <api_efficiency>
            <batch_requests>Group API calls when possible</batch_requests>
            <caching_strategy>Cache non-critical data for 30 seconds</caching_strategy>
            <rate_limit_buffer>Use only 80% of API rate limits for safety</rate_limit_buffer>
        </api_efficiency>

        <memory_management>
            <data_retention>Keep only essential data in shared memory</data_retention>
            <cleanup_intervals>Clear old strategy transition signals every 5 minutes</cleanup_intervals>
            <lazy_loading>Load strategy configurations only when needed</lazy_loading>
        </memory_management>

        <queue_optimization>
            <priority_processing>Process CRITICAL messages first</priority_processing>
            <batch_processing>Group similar message types when possible</batch_processing>
            <deadlock_prevention>Timeout mechanisms for all queue operations</deadlock_prevention>
        </queue_optimization>
    </optimization_rules>

    <!-- DEPLOYMENT CONSIDERATIONS -->
    <deployment_ready>
        <configuration>
            <environment_variables>All API keys, database credentials via environment</environment_variables>
            <fallback_configs>Default values for all configuration parameters</fallback_configs>
            <monitoring_endpoints>Health check URLs for all processes</monitoring_endpoints>
        </configuration>

        <aws_ec2_specific>
            <startup_scripts>Automatic process restart on failure</startup_scripts>
            <logging_destination>CloudWatch integration for production monitoring</logging_destination>
            <resource_monitoring>CPU and memory usage alerts</resource_monitoring>
        </aws_ec2_specific>
    </deployment_ready>

    <!-- SAFETY AND RISK MANAGEMENT -->
    <safety_rules>
        <strategy_transitions>
            <max_daily_transitions>3 per symbol to prevent over-trading</max_daily_transitions>
            <cooldown_period>15 minutes between transitions for same symbol</cooldown_period>
            <emergency_stop>Manual override capability for all automated decisions</emergency_stop>
        </strategy_transitions>

        <api_protection>
            <rate_limit_enforcement>Hard stops at 90% of API limits</rate_limit_enforcement>
            <connection_limits>Maximum 5 concurrent API connections</connection_limits>
            <error_circuit_breaker>Stop API calls after 5 consecutive failures</error_circuit_breaker>
        </api_protection>

        <data_integrity>
            <state_validation>Verify shared memory consistency every 60 seconds</state_validation>
            <backup_mechanisms>Persist critical state to database every 5 minutes</backup_mechanisms>
            <corruption_recovery>Automatic recovery from shared memory corruption</corruption_recovery>
        </data_integrity>
    </safety_rules>
</trading_system_implementation_rules>
